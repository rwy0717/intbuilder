#include <stdint.h> // HACK
#include <stddef.h> // HACK

//////////////////////////////////

#include <OMR/Model/Value.hpp>
#include <OMR/Model/OperandStack.hpp>
#include <OMR/Model/OperandArray.hpp>
#include <OMR/Model/Register.hpp>
#include <OMR/Model/Pc.hpp>

#include <VirtualMachineState.hpp>
#include <TypeDictionary.hpp>

#include <cstdint>
#include <cassert>

namespace Model = OMR::Model;
namespace JB = OMR::JitBuilder;

enum class Op : std::uint8_t {
	PUSH_CONST, ADD, PUSH_LOCAL, POP_LOCAL, CALL
};

class Interpreter;

using CompiledFn = void(*)(Interpreter*);

/// Function header.
///
struct Func {
	CompiledFn cbody = nullptr; //< compiled body ptr.
	std::size_t nlocals = 0;
	std::size_t nparams = 0;
	std::uint8_t body[]; //< bytecode body. trailing data.
};

/// Function header. Offsets of fields.
///
struct FuncOffset {
	static constexpr std::size_t CBODY = offsetof(Func, cbody);
	static constexpr std::size_t NLOCALS = offsetof(Func, nlocals);
	static constexpr std::size_t NPARAMS = offsetof(Func, nparams);
	static constexpr std::size_t BODY = offsetof(Func, body);
};

/// Function header. Define type in JitBuilder.
///
void defineFunc(JB::TypeDictionary* t) {
	t->DefineStruct("Func");
	t->DefineField("Func", "cbody", t->Address, FuncOffset::CBODY);
	t->DefineField("Func", "nlocals", t->Word, FuncOffset::NLOCALS);
	t->DefineField("Func", "nparams", t->Word, FuncOffset::NPARAMS);
	t->DefineField("Func", "body", t->NoType, FuncOffset::BODY);
	t->CloseStruct("Func");
}

/// The main interpreter function type.
///
using InterpretFn = void(*)(Interpreter*, Func* target);

/// The interpreter state.
///
struct Interpreter {
public:
	static constexpr std::size_t STACK_SIZE = 1024; //< in bytes
	static constexpr std::uint8_t POISON = 0x5e;

	Interpreter()
		: _sp(nullptr),
		  _pc(nullptr),
		  _fp(nullptr),
		  _interpretfn(nullptr) {
		memset(_stack, POISON, STACK_SIZE);
	}

	void run(Func* target) {
		// todo: check if cbody is non-null, which implies it's compiled.
		interpret(target);
	}

	void interpret(Func* target) {
		assert(_interpretfn);
		_interpretfn(this, target);
	}

private:
	friend class InterpreterOffset;

	std::uint8_t* _sp; //< Stack pointer. Pointer to top of stack.
	std::uint8_t* _pc; //< Program counter. Pointer to current bytecode.
	Func* _fp; //< Function pointer. Pointer to current function.
	InterpretFn _interpretfn; //< Interpreter main function. Generated by JitBuilder.
	std::uint8_t _stack[STACK_SIZE];
};

struct InterpreterOffset {
	static constexpr std::size_t SP = offsetof(Interpreter, _sp);
	static constexpr std::size_t PC = offsetof(Interpreter, _pc);
	static constexpr std::size_t FP = offsetof(Interpreter, _fp);
	// static constexpr std::size_t STACK = offsetof(Interpreter, _stack);
};

/// 
void defineInterpreter(JB::TypeDictionary* t) {
	t->DefineStruct("Interpreter");
	t->DefineField("Interpreter", "_sp", t->pInt8, InterpreterOffset::SP);
	t->DefineField("Interpreter", "_pc", t->pInt8, InterpreterOffset::PC);
	t->DefineField("Interpreter", "_fp", t->PointerTo(t->LookupStruct("Func")));
	t->DefineField("Interpreter", "_interpretfn", t->Address);
	// TODO: t->DefineField("")
}

/// JIT Helper: run a function in the interpreter.
///
extern "C" void run(Interpreter* interpreter, Func* target) {
	interpreter->run(target);
}

/// Wrapper for accessing Func structures through the machine model.
///
template <Model::Mode M>
class Function;

template <>
class Function<Model::Mode::VIRT> {

	Function(Model::CPtr<Func> function)
		: _function(function.unpack()) {}

	Model::CSize nlocals(OMR_UNUSED JB::IlBuilder* b) {
		return Model::CSize::pack(_function->nlocals);
	}

	Model::CSize nparams(OMR_UNUSED JB::IlBuilder* b) {
		return Model::CSize::pack(_function->nparams);
	}

	Model::CPtr<std::uint8_t> body(OMR_UNUSED JB::IlBuilder* b) {
		return Model::CPtr<std::uint8_t>::pack(_function->body);
	}

	Model::CValue<CompiledFn> cbody(OMR_UNUSED JB::IlBuilder* b) {
		return Model::CValue<CompiledFn>::pack(_function->cbody);
	}

	Func* unpack() { return _function; }

private:
	Func* _function;
};

template <>
class Function<Model::Mode::REAL> {
public:
	Function(Model::RPtr<Func> function)
		: _function(function.unpack()) {}

	Model::RSize nlocals(JB::IlBuilder* b) {
		return Model::RSize::pack(
			b->Const(0)
		);
	}

	Model::RSize nparams(JB::IlBuilder* b) {
		return Model::RSize::pack(
			b->Const(0)
		);
	}

	Model::RPtr<std::uint8_t> body(JB::IlBuilder* b) {
		return Model::RPtr<std::uint8_t>::pack(
			b->Const(0));
	}

	Model::RValue<CompiledFn> cbody(JB::IlBuilder* b) {
		return Model::RValue<CompiledFn>::pack(
			b->Const(0));
	}

	JB::IlValue* unpack() { return _function; }

private:
	JB::IlValue* _function;
};

template <Model::Mode M>
class Machine : public JB::VirtualMachineState {
public:
	Machine(JB::IlBuilder b, JB::IlValue* address)
		: stack(b, b->StructFieldInstanceAddress("Interpreter", "_sp", address)),
		  locals(b, nullptr),
		  pc(b->StructFieldInstanceAddress("Interpreter", "_pc", address),
		     b->StructFieldInstanceAddress("Interpreter", "_fp", addresss)),
		  function() {}

	Model::OperandStack<M> stack;
	Model::OperandArray<M> locals;
	Model::Pc<M> pc;
	Function<M> function;
};

void initialize(JB::IlBuilder* b, Machine<Model::Mode::REAL>& machine, JB::IlValue* interpreter, JB::IlValue* func) {
	JB::TypeDictionary* t = b->typeDictionary();

	machine.stack.initialize(b, );
	// machine.locals
	// machine.pc
	// machine.function
	assert(0);
}

void initialize(Machine<Model::Mode::VIRT>& machine) {
	assert(0);
}

template <Model::Mode M>
struct FunctionEntryBuilder {
	static constexpr std::size_t LOCAL_SIZE = 4;
	void build(Machine<M>& machine, JB::IlBuilder* b) {
		machine.stack.reserve(b, mul(b, machine.pc.function().nlocals(), LOCAL_SIZE));
	}
};

struct CallBuilderBase {
protected:
	static constexpr std::size_t INSTR_SIZE = 9;
	static constexpr std::size_t TARGET_OFFSET = 1;
};

template <Model::Mode>
struct CallBuilder;

template <>
struct CallBuilder<Model::Mode::VIRT> : CallBuilderBase {
	void build(Machine<Model::Mode::VIRT>& machine, JB::IlBuilder* b) {
		machine.pc.next(b, Model::CUInt(b, INSTR_SIZE));
	}
};

template <>
struct CallBuilder<Model::Mode::REAL> : CallBuilderBase {
	void build(Machine<Model::Mode::REAL>& machine, JB::IlBuilder* b) {
		machine.pc.next(b, Model::RUInt(b, INSTR_SIZE));
	}
};

template <Model::Mode M>
struct PushConstBuilder {
	static constexpr std::size_t INSTR_SIZE = 5;
	static constexpr std::size_t INSTR_CONST_OFFSET = 1;

	void build(Machine<M>& machine, JB::IlBuilder* b) {
		Model::UInt<M> c = machine.pc.immediateInt(b, Model::UInt<M>(b, INSTR_CONST_OFFSET));
		machine.stack.push(b, c.toIl(b));
		machine.pc.next(b, Model::UInt<M>(b, INSTR_SIZE));
	}
};

template <Model::Mode M>
struct AddBuilder {
	static constexpr std::size_t INSTR_SIZE = 1;

	void build(Machine<M>& machine, JB::IlBuilder* b) {
		JB::IlValue* rhs = machine.stack.popInt(b);
		JB::IlValue* lhs = machine.stack.popInt(b);
		machine.stack.push(b, b->Add(lhs, rhs));
		machine.pc.next(b, Model::UInt<M>(b, INSTR_SIZE));
	}
};

template <Model::Mode M>
struct PushLocalBuilder {
	static constexpr std::size_t INSTR_SIZE = 5;
	static constexpr std::size_t INSTR_INDEX_OFFSET = 1;

	void build(Machine<M>& machine, JB::IlBuilder* b) {
		Model::UInt<M> index = machine.pc.immediateUInt(b, Model::UInt<M>(b, INSTR_INDEX_OFFSET));
		JB::IlValue* value = machine.locals.at(b, index);
		machine.stack.push(b, value);
		machine.pc.next(b, Model::UInt<M>(b, INSTR_SIZE));
	}
};

template <Model::Mode M>
struct PopLocalBuilder {
	static constexpr std::size_t INSTR_SIZE = 5;
	static constexpr std::size_t INSTR_INDEX_OFFSET = 1;

	virtual void build(Machine<M>& machine, JB::IlBuilder* b) {
		Model::UInt<M> index = machine.pc.immediateUInt(b, Model::UInt<M>(b, INSTR_INDEX_OFFSET));
		machine.locals.set(b, index, machine.stack.popUInt(b));
		machine.pc.next(b, Model::UInt<M>(b, INSTR_SIZE));
	}
};

template <Model::Mode M>
struct BranchBuilder {
	static constexpr std::size_t INSTR_SIZE = 5;
	static constexpr std::size_t INSTR_TARGET_OFFSET = 1;

	void build(Machine<M>& machine, JB::IlBuilder* b) {
		Model::UInt<M> target = machine.pc.immediateUInt(b, Model::UInt<M>(b, INSTR_TARGET_OFFSET));
		JB::IlValue* value = machine.locals.at(b, index);
		machine.stack.push(b, value);
		machine.pc.next(b, Model::add(b, Model::UInt<M>(b, INSTR_SIZE), target));
	}
};

template <Model::Mode M>
struct InstructionDispatch;

template <>
struct InstructionDispatch<Model::Mode::REAL> {
	Model::RUIntPtr target(JB::IlBuilder* b, Model::RUIntPtr pc) {
		return Model::RUIntPtr::pack(b->Const(nullptr));
		// return Model::RUIntPtr::pack(b->LoadAt(b->typeDictionary()->XXX, pc.unpack()));
	}
};

template <>
struct InstructionDispatch<Model::Mode::VIRT> {
	Model::CUIntPtr target(JB::IlBuilder* b, Model::CUIntPtr pc) {
		// translate pc to bytecode index.
		return Model::CUIntPtr::pack(
			static_cast<std::uintptr_t>(
				*reinterpret_cast<std::uint8_t*>(pc.unpack())));
	}
};

using RealInstructionDispatch = InstructionDispatch<Model::Mode::REAL>;
using VirtInstructionDispatch = InstructionDispatch<Model::Mode::VIRT>;

// 	PUSH_CONST, ADD, PUSH_LOCAL, POP_LOCAL

template <Model::Mode M>
struct InstructionTable {

};

template <Model::Mode M>
struct InstructionSet {
	template <typename Instruction>
	void buildInstruction(Instruction& instruction, JB::IlBuilder* b) {
		Machine<M> machine(
			b->StructFieldInstanceAddress("Interpreter", "_sp", interpreter))
		);
		machine.initialize(b);
		instruction.build(machine, b);
	}
	// void notifySet(InstructionTable<M>& table) {
	// 	// table.register((unsigned int)Op::PUSH_CONST, new PushConstBuilder<M>());
	// 	// table.register((unsigned int)Op::ADD,        new AddBuilder<M>());
	// 	// table.register((unsigned int)Op::POP_LOCAL,  new PopLocalBuilder<M>());
	// 	// table.register((unsigned int)Op::PUSH_LOCAL, new PushLocalBuilder<M>());
	// }
};

/// Define all types and structs in jitbuilder
///
void defineTypes(JB::TypeDictionary* t) {
	defineFunc(t);
	defineInterpreter(t);
}

class InterpreterBuilder : public JB::MethodBuilder {
public:
	virtual void BuildIl(JB::IlBuilder* b) override {

		JB::TypeDictionary* t = b->typeDictionary();
	
		DefineName("interpret");
		DefineLine("362");
		DefineFile("example.cpp");

		defineTypes(t);

		DefineParameter("interpreter", t->PointerTo(t->LookupStruct("Interpreter")));
		DefineParameter("func", t->PointerTo(t->LookupStruct("Func")));

		DefineReturnType(t->NoType);

		Machine<Model::Mode::REAL> machine;
		
		machine.initialize(
			this,
			Model::RPtr<Interpreter>::pack(b->GetParameter("interpreter")),
			Model::RPtr<Func>::pack(b->GetParameter("func"))
		);

		AllLocalsHaveBeenDefined();
	}

private:
};

InterpretFn buildInterpret() {
	// Machine<Model::Mode::REAL> machine = mkmachine<
	// InstructionSet<Model::Mode::REAL> instructions;

	return nullptr;
}

/////////////////////////// Instruction Set

struct {
	Func header;
	
};

extern "C" int main(int argc, char** argv) {
	InstructionSet<OMR::Model::Mode::REAL> set;
	InterpretFn interpret = buildInterpret(set);
	return 0;
}
