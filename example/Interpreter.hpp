#if !defined(INTERPRETER_HPP_)
#define INTERPRETER_HPP_

#include <cstdint>
#include <cstddef>
#include <cstdlib>
#include <cstring>
#include <cassert>

#include <Example.hpp>
#include <Instructions.hpp>
#include <BytecodeMethodBuilder.hpp>

class Interpreter;
class JitTypes;
class JitHelpers;
struct Func;

/// The main interpreter function type. Generated by JitBuilder.
///
using InterpretFn = void(*)(Interpreter*, Func*);

/// Any JIT-compiled function.
///
using CompiledFn = void(*)(Interpreter*);

/// Function header.
///
struct Func {
	Func() = default;

	Func(std::size_t nlocals, std::size_t nparams)
		: cbody(nullptr), nlocals(nlocals), nparams(nparams) {}

	CompiledFn cbody = nullptr; //< compiled body ptr.
	std::size_t nlocals = 0;
	std::size_t nparams = 0;
	std::uint8_t body[]; //< bytecode body. trailing data.
};

/// The interpreter state.
class Interpreter {
public:
	static constexpr std::size_t  STACK_SIZE = 4*8; //< in bytes
	static constexpr std::uint8_t POISON     = 0x5e;

	Interpreter() :
		_compiler(), _sp(nullptr), _pc(nullptr), _startpc(nullptr), _fp(nullptr) {
		std::memset(_stack, POISON, STACK_SIZE);

		if (_interpret == nullptr) {
			_interpret = compile_interpret_fn();
		}

		initialize();
	}

	void run(Func* target) {
		if (target->cbody != nullptr) {
			run_cbody(target);
		} else {
			interpret_body(target);
		}
	}

	void interpret_body(Func* target) {
		assert(_interpret != nullptr);
		do_interpret_body(target);
	}

	void compile(Func* target);

	void run_cbody(Func* target) {
		assert(target->cbody != nullptr);
		do_run_cbody(target);
	}

	std::int64_t peek(std::size_t offset = 0) const {
		return reinterpret_cast<const std::int64_t*>(_stack)[offset];
	}

	const std::uint8_t* sp() const { return _sp; }

private:
	friend class JitHelpers;
	friend class JitTypes;

	static InterpretFn compile_interpret_fn();

	static InterpretFn _interpret;

	void initialize() { _sp = _stack; }

	void do_interpret_body(Func* target) {
		_interpret(this, target);
	}

	void do_run_cbody(Func* target) {
		target->cbody(this);
	}

	BytecodeMethodCompiler _compiler;
	std::uint8_t* _sp;                //< Stack pointer. Pointer to top of stack.
	std::uint8_t* _pc;                //< Program counter. Pointer to current bytecode.
	std::uint8_t* _startpc;           //< pc at function entry. Used for absolute jumps.
	Func* _fp;                        //< Function pointer. Pointer to current function.
	std::uint8_t _stack[STACK_SIZE];
};

#endif // INTERPRETER_HPP_
